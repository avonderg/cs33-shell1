# 5-shell-1
To begin with, my program first enters the REPL in the main function of my program. I initialize all the variables that I plan on using, and then call the read function to read in the standard input. After error checking, I then parse and tokenize the buffer. However, I don’t handle file redirects immediately upon parsing. Rather, I store the parsed and tokenized input including file redirects into a temporary array, ‘w_sym’, which I then use in the parent parse() function. Within parse(), I loop through the tokens array that I created, checking for the existence of any of the three file redirection symbols. If one is found, then I add the (i+2)th element of w_sym into the argv array instead of the current element. After some more error checking using flags to ensure that there are no illegal uses of file redirects, I then call a function called set_path() to set the file path that must be passed into execv(). 

Within set_path, I loop through my tokens array (as it includes slashes, whereas w_sym does not) , and set the first element of tokens that is not a file redirect equal to the file path. Once this is done, back in the main, I call my function, built_in, which checks if the path is equal to any of the four built_in commands (the path must be checked, as sometimes, a built_in can be included in the file path). After error checking, the built_ins are handled appropriately (i.e., their respective functions are called), and the function returns based on whether it was successful in calling a built_in, found an error, or if a built_in was not found. 

If a builtin was not found, then the program forks and execv()s a new child process. This is because file redirections do not need to be checked if a builtin was included in the command line. Thus, within the child process, the function file_redirect is called, which, based on whether or not the input or output files are not null, opens the file to either write or read, with the appropriate flags and modes set. Then, execv() is called, taking in the file path as its first input, and argv as its second. It hence replaces the newly created child process with the program in the command line.
